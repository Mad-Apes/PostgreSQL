# PostgreSQL中DDL支不支持事务？
```
支持。PostgreSQL中对DDL的处理方式和普通的DML类似，也是支持事务的。
```

# PostgreSQL中对BLOB数据的处理支不支持事务？
```
支持。对BLOB(bytea或large object)数据的事务处理和普通数据的差别不大，但由于BLOB数据较大涉及BLOB的事务会产生很大的WAL日志文件。
```

# PostgreSQL中很大的数据，比如BLOB如何在数据页面中存储？
```
默认数据页面的大小是8K，当有很大数据时可能导致一个页面放不下整个数据行。针对这种情况，PostgreSQL采取一种叫做TOAST的技术，对于比较大的列只在行中放一个类似指针的东西，完整的数据放在另一个单独的TOAST表中。在TOAST表中数据被切割成若干个chunk,每个chunck以一个数据行的形式存放。
```

# PostgreSQL中可重复读和可串行化隔离级别都不会出现幻读那它们的区别是什么？
```
根据SQL规约，能够回避幻读就已经满足了“可串行化”隔离级别的要求。但是SQL规约定义的“可串行化”并不是严格意义上的可串行化，仅仅能回避幻读不等于可以把并发执行的几个事务转化为几个事务严格按某个顺序先后执行 。PostgreSQL中的可重复读可以回避幻读但不是严格意义上的可串行化，但是可串行化就是。顺便说一下，Oracle中的可串行化也不是严格意义上的可串行化，实际上它等价于PostgreSQL中的可重复读。
```

# PostgreSQL中事务ID分配完了怎么办？
```
从头开始重新分配（实际上从3开始重新分配，0,1,2已做为特殊用途，这称之为事务回卷）。但这样可能形成事务ID冲突的问题，PostgreSQL中解决这个问题的措施有两个。第一，定期清理留在数据文件中的过老的事务ID，将它们统一设置为一个特殊值（2），在做事务新旧比较时，这个特殊的事务ID永远比其他普通的事务ID旧。这就保证了系统中事务ID的范围跨度不会过大。第二，在做事务新旧比较时不是简单的比较两个事务ID的算数值大小，而且考虑到了特殊事务ID和事务回卷的情况。比如根据内部的比较规则，无符号INT类型的事务ID 0x00000005比0xFFFFFFFF新。因为第一个措施已经保证了系统中事务ID间的跨度不会过大(不超过2^31)，所以0x00000005一定是事务ID回卷后的结果而0xFFFFFFFF还没有发生回卷(或者说比0x00000005少回卷一次)
```
