Q&A：

1、Q:PostgreSQL中DDL支不支持事务？

A:支持。PostgreSQL中对DDL的处理方式和普通的DML类似，也是支持事务的。

 
2、 Q:PostgreSQL中对BLOB数据的处理支不支持事务？

A:支持。对BLOB(bytea或large object)数据的事务处理和普通数据的差别不大，但由于BLOB数据较大涉及BLOB的事务会产生很大的WAL日志文件。

 
3、Q:PostgreSQL中很大的数据，比如BLOB如何在数据页面中存储？

A:默认数据页面的大小是8K，当有很大数据时可能导致一个页面放不下整个数据行。针对这种情况，PostgreSQL采取一种叫做TOAST的技术，对于比较大的列只在行中放一个类似指针的东西，完整的数据放在另一个单独的TOAST表中。在TOAST表中数据被切割成若干个chunk,每个chunck以一个数据行的形式存放。

 
4、Q:PostgreSQL中可重复读和可串行化隔离级别都不会出现幻读那它们的区别是什么？

A:根据SQL规约（特意查了下SQL规约），可串行化指可并发执行的影响和几个事务严格按某个顺序先后执行相同。所以不出现脏读，不可重复读和幻读不代表可以达到可串行化。

顺便说一下，Oracle的“可串行化”是假的，是违背SQL标准的。Oracle的“可串行化”实际上等价于PG的“可重复读”，保证不会出现脏读，不可重复读和幻读，但不能保证执行结果等价于各个事务按某个顺序串行执行（详见：http://blog.chinaunix.net/uid-20726500-id-3900530.html）。而PG的“可串行化”才是严格意义上的可串行化,也是符合SQL标准的可串行化。（详见：http://blog.chinaunix.net/uid-20726500-id-3900541.html）
 
5、Q:PostgreSQL中事务ID分配完了怎么办？

A:从头开始重新分配（实际上从3开始重新分配，0,1,2已做为特殊用途，这称之为事务回卷）。但这样可能形成事务ID冲突的问题，PostgreSQL中解决这个问题的措施有两个。第一，定期清理留在数据文件中的过老的事务ID，将它们统一设置为一个特殊值（2），在做事务新旧比较时，这个特殊的事务ID永远比其他普通的事务ID旧。这就保证了系统中事务ID的范围跨度不会过大。第二，在做事务新旧比较时不是简单的比较两个事务ID的算数值大小，而且考虑到了特殊事务ID和事务回卷的情况。比如根据内部的比较规则，无符号INT类型的事务ID 0x00000005比0xFFFFFFFF新。因为第一个措施已经保证了系统中事务ID间的跨度不会过大(不超过2^31)，所以0x00000005一定是事务ID回卷后的结果而0xFFFFFFFF还没有发生回卷(或者说比0x00000005少回卷一次)。
