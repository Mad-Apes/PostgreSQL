# 字符串类型
```
-------------------------------------------------------------------------------
| character varying(n), varchar(n) | 变长，字符最大数有限制
-------------------------------------------------------------------------------
| character(n), char(n)            | 变长，字符数没有达到最大数时使用空白填充
-------------------------------------------------------------------------------
| text                             | 变长，没有长度限制
-------------------------------------------------------------------------------
```

## 要点
```
## character varying(n), varchar(n)
  n是一个正整数，如果存储的字符串长度超过N则报错，除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度。没有超过 N 仅存储字符串的实际位数。
  如果不指定 n ，即不声明长度，该类型将存储任意长度的字符串。

## character(n), char(n)
  n是一个正整数，如果字符串的长度超过 n 则报错，除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度，没有超过 n 则用空白填充。
  如果不声明长度，则等效于 character(1)

## 验证
  postgres=# \d test_char
                      Table "public.test_char"
   Column |         Type         | Collation | Nullable | Default
  --------+----------------------+-----------+----------+---------
   col_1  | character(4)         |           |          |
   col_2  | character varying(4) |           |          |

   postgres=# INSERT INTO test_char VALUES('a', 'a');
   INSERT 0 1

  计算两个字符串长度
  postgres=# SELECT col_1, length(col_1), char_length(col_1),col_2, length(col_2), char_length(col_2) FROM test_char;
   col_1 | length | char_length | col_2 | length | char_length
  -------+--------+-------------+-------+--------+-------------
   a     |      1 |           1 | a     |      1 |           1

  计算两个字符串实际占用物理空间的大小
  postgres=# SELECT col_1, length(col_1), octet_length(col_1),col_2, length(col_2), octet_length(col_2) FROM test_char;
   col_1 | length | octet_length |  col_2   | length | octet_length
  -------+--------+--------------+----------+--------+--------------
   a     |      1 |            4 | a        |      1 |            1

# varchar 和 char 在性能上几乎没有差别。只是char存储字符串长度不够使空白填充，会带来存储空间的浪费

# text 可以存储任意长度的字符串。和没有声明长度的 varchar 几乎没有差别。
```
## 注意事项
```
    1:如果我们明确地把一个值造型成character varying(n)或者character(n)， 那么超长的值将被截断成n个字符，而不会抛出错误
    如：
      SELECT '2222222222222222'::varchar(5);
      SELECT '2222222222222222'::char(5);
    以上两SQL结果都为 22222

    2：character 的值物理上都是用空白填充[拖尾填充]到指定长度。并且以这种方式存储和显示。
       拖尾的空白被当作是没有意义的，比较两个character时不会考虑他们。

    3：在character varying和text值里， 结尾的空白语意上是有含义的，并且在使用模式匹配（如LIKE和正则表达式）时也会被考虑。

    4：在任何情况下，能被存储的最长的字符串是1GB。

    5：如果你想要存储没有指定上限的长串，使用text或没有长度声明的character varying，而不是给出一个任意长度限制
```
## 性能问题
```
    这三种类型时间没有性能差别。只不过在使用character时，因需要填充空白，所以需要更多的存储尺寸。并且存储到一个有长度约束的列时，还需要额外的CPU周期来检查长度。

    虽然在某些其它的数据库系统里，character(n)有一定的性能优势，但在PostgreSQL里没有。
    事实上，character(n)通常是这三种类型之中最慢的一个，因为它需要额外的存储开销。在大多数情况下，应该使用text或者character varying。
```
## 特殊的字符类型
```
-----------------------------------------------------------------------------------------------------------------
名称   | 存储尺寸 |   描述
-----------------------------------------------------------------------------------------------------------------
"char" |  1字节   | 单字节内部类型。类型"char"（注意引号）和 char(1)是不一样的。它在系统内部用于系统目录当做简化的枚举类型用。
-----------------------------------------------------------------------------------------------------------------
name   |  16字节  | 用于对象名的内部类型。用于在内部系统目录中存储标识符并且不是给一般用户使用的
-----------------------------------------------------------------------------------------------------------------
```
